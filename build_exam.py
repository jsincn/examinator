


from build_new_mp_questions import modify_mp_questions
from data_model import Exam, MultipleChoiceExamQuestion
from render_mc_problem import render_mc_problem
from render_problem import render_problem
from jinja2 import Environment, FileSystemLoader
import os
import sys
import tempfile
import shutil
import subprocess
from datetime import datetime


def render_exam_tex(problem_filenames: list, template_path: str = "templates/exam_template.jinja2") -> str:
    """
    Render the exam.tex file using the Jinja template.
    
    Args:
        problem_filenames: List of problem filenames to include
        template_path: Path to the Jinja template file
        
    Returns:
        Rendered LaTeX string
    """
    template_dir = os.path.dirname(os.path.abspath(template_path))
    template_name = os.path.basename(template_path)
    
    env = Environment(loader=FileSystemLoader(template_dir))
    template = env.get_template(template_name)
    
    context = {
        'problem_files': problem_filenames,
    }
    
    return template.render(context)


def override_examconf(exam: Exam, exam_config_path: str):
    """Override the examconf.tex file with metadata from the Exam model."""
    # Parse start and end times to extract date and time components
    # Assuming start_time and end_time are in format like "YYYY-MM-DD HH:MM" or similar
    try:
        start_dt = datetime.fromisoformat(exam.start_time.replace(' ', 'T'))
        end_dt = datetime.fromisoformat(exam.end_time.replace(' ', 'T'))
    except:
        # Fallback to current date if parsing fails
        start_dt = datetime.now()
        end_dt = datetime.now()
    
    # Generate examconf.tex content
    examconf_content = f"""% This file is generated by TUMexam.

\\title{{{exam.exam_title}}}
\\type{{}}
\\module{{{exam.module}}}
\\startdate{{{start_dt.day}}}{{{start_dt.month}}}{{{start_dt.year}}}
\\stopdate{{{end_dt.day}}}{{{end_dt.month}}}{{{end_dt.year}}}
\\starttime{{{start_dt.strftime('%H:%M')}}}
\\stoptime{{{end_dt.strftime('%H:%M')}}}
\\lang{{english}}
\\department{{School of Computation, Information, and Technology}}
\\chair{{{exam.exam_chair}}}
\\examiner{{{exam.examiner}}}

\\submissionfalse
\\singlepasstrue
\\halfcreditstrue
\\registrationstickertrue
\\externalproblemsfalse
\\coversheetfalse
\\booklet
\\seriffalse
\\subproblemarabicfalse
\\minimaltitlepagefalse

\\noproblemcreditsfalse
\\noproblemfalse
\\notitlefalse
\\nocorrectorboxfalse
\\singlesidefalse
"""
    
    # Write the examconf.tex file
    with open(exam_config_path, 'w') as f:
        f.write(examconf_content)


def build_exam(exam: Exam, status_callback=None):
    """
    Build exam LaTeX files.
    
    Args:
        exam: Exam object to build
        status_callback: Optional callback function(status_message, progress) for UI updates
    """
    if status_callback:
        status_callback("Setting up workspace...", 0.1)
    
    tmp_dir = tempfile.mkdtemp()
    shutil.copytree('./latex_template', os.path.join(tmp_dir, 'latex_template'))
    base_dir = os.path.join(tmp_dir, 'latex_template')
    exam_config = f"{base_dir}/conf/generated/examconf.tex"
    
    if status_callback:
        status_callback("Configuring exam metadata...", 0.2)
    
    override_examconf(exam, exam_config)

    if status_callback:
        status_callback("Creating problem files...", 0.3)

    # Create problem files
    problems_dir = os.path.join(base_dir, 'problems')
    os.makedirs(problems_dir, exist_ok=True)

    problem_filenames = []
    total_problems = len(exam.exam_content.problems)
    for idx, problem in enumerate(exam.exam_content.problems, start=1):
        if status_callback:
            progress = 0.3 + (idx / total_problems) * 0.4
            status_callback(f"Rendering problem {idx} of {total_problems}...", progress)
        
        problem_filename = f"problem_{idx:02d}.tex"
        problem_path = os.path.join(problems_dir, problem_filename)
        problem_filenames.append(problem_filename)
        
        # Render the problem using the Jinja template
        if isinstance(problem, MultipleChoiceExamQuestion):
            new_problem = modify_mp_questions(problem)
            problem_latex = render_mc_problem(new_problem, problem_number=idx)
        else:
            problem_latex = render_problem(problem, problem_number=idx)
        
        with open(problem_path, 'w') as f:
            f.write(problem_latex)

    if status_callback:
        status_callback("Generating main exam template...", 0.8)

    # Generate exam.tex from template
    exam_tex_content = render_exam_tex(problem_filenames)
    exam_tex_path = os.path.join(base_dir, 'exam.tex')
    with open(exam_tex_path, 'w') as f:
        f.write(exam_tex_content)
    
    if status_callback:
        status_callback("LaTeX files generated successfully!", 1.0)
      
    # ============================================================================
    # LaTeX PDF COMPILATION - COMMENTED OUT FOR WINDOWS COMPATIBILITY
    # ============================================================================
    # The following code compiles LaTeX to PDF. This requires LaTeX installation
    # (MiKTeX or TeX Live) which is not available on all Windows systems.
    # Uncomment this section if you have LaTeX installed and want to generate PDFs.
    # ============================================================================
    
    # Build the exam PDF - cross-platform solution
    # Priority: Use Makefile if available (macOS/Linux), fallback to pdflatex (Windows)
    original_dir = os.getcwd()
    os.chdir(base_dir)
    
    # Check if make is available (Unix/Linux/Mac - typically available by default)
    make_available = shutil.which('make') is not None
    
    if make_available:
        # Use Makefile if available (preferred method for macOS/Linux)
        # This preserves the original behavior for Unix-based systems
        result = os.system('make')
        result_2 = os.system('make solution')
        if result != 0:
            raise RuntimeError(f"make failed with exit code {result}")
        if result_2 != 0:
            raise RuntimeError(f"make solution failed with exit code {result_2}")
    else:
        # Windows fallback: use pdflatex directly (make is typically not available on Windows)
        # Check if pdflatex is available in PATH
        pdflatex = shutil.which('pdflatex')
        
        # If not in PATH, check common Windows installation locations
        if not pdflatex:
            common_paths = [
                r"C:\Program Files\MiKTeX\miktex\bin\x64\pdflatex.exe",
                r"C:\Program Files (x86)\MiKTeX\miktex\bin\pdflatex.exe",
                os.path.expanduser(r"~\AppData\Local\Programs\MiKTeX\miktex\bin\x64\pdflatex.exe"),
                r"C:\texlive\2024\bin\win32\pdflatex.exe",
                r"C:\texlive\2023\bin\win32\pdflatex.exe",
            ]
            for path in common_paths:
                if os.path.exists(path):
                    pdflatex = path
                    break
        
        if not pdflatex:
            error_msg = (
                "Neither 'make' nor 'pdflatex' found.\n\n"
                "To fix this on Windows, please install a LaTeX distribution:\n"
                "1. MiKTeX (Recommended): https://miktex.org/download\n"
                "   - Download and run the installer\n"
                "   - Make sure to select 'Add MiKTeX to PATH' during installation\n"
                "   - Or add MiKTeX bin folder to your system PATH manually\n\n"
                "2. TeX Live: https://www.tug.org/texlive/windows.html\n"
                "   - Download and run install-tl-windows.exe\n"
                "   - Add TeX Live bin folder to your system PATH\n\n"
                "After installation, restart your terminal/IDE and try again."
            )
            raise RuntimeError(error_msg)
        
        exam_tex = os.path.join(base_dir, 'exam.tex')
        exam_tex_basename = os.path.splitext(os.path.basename(exam_tex))[0]
        
        def run_pdflatex(tex_file, jobname=None, description="PDF"):
            """Run pdflatex with error handling for MiKTeX update checks."""
            cmd = [pdflatex, '-interaction=nonstopmode', '-output-directory=.', tex_file]
            if jobname:
                cmd.insert(-1, f'-jobname={jobname}')
            
            result = subprocess.run(
                cmd,
                capture_output=True, text=True, cwd=base_dir
            )
            
            # Check for MiKTeX update requirement
            if result.returncode != 0:
                error_output = (result.stderr or result.stdout or "").lower()
                if "you have not checked for miktex updates" in error_output:
                    # Try to automatically run the update check
                    try:
                        # Try to find mpm (MiKTeX Package Manager)
                        mpm_paths = [
                            shutil.which('mpm'),
                            os.path.join(os.path.dirname(pdflatex), 'mpm.exe'),
                            os.path.join(os.path.dirname(pdflatex), '..', 'miktex', 'bin', 'x64', 'mpm.exe'),
                        ]
                        mpm = None
                        for path in mpm_paths:
                            if path and os.path.exists(path):
                                mpm = path
                                break
                        
                        if mpm:
                            # Run update check (this may take a while, but it's necessary)
                            print("MiKTeX update check required. Running automatically...")
                            update_result = subprocess.run(
                                [mpm, '--update', '--auto-install'],
                                capture_output=True, text=True, timeout=120
                            )
                            # Try pdflatex again after update check
                            result = subprocess.run(
                                cmd,
                                capture_output=True, text=True, cwd=base_dir
                            )
                            if result.returncode == 0:
                                return result
                    except (subprocess.TimeoutExpired, FileNotFoundError, Exception) as e:
                        # If automatic update fails, provide instructions
                        pass
                    
                    # If automatic update didn't work, provide clear instructions
                    error_msg = (
                        f"pdflatex failed: MiKTeX requires an update check on first use.\n\n"
                        "To fix this, run ONE of the following:\n\n"
                        "Option 1 (Recommended - GUI):\n"
                        "  Open 'MiKTeX Console' from Start Menu, then:\n"
                        "  - Click 'Check for updates'\n"
                        "  - Click 'Update now' if updates are found\n\n"
                        "Option 2 (Command Line):\n"
                        "  Open PowerShell (as Administrator) and run:\n"
                        "  mpm --update --auto-install\n\n"
                        "After running the update check once, this error will not appear again."
                    )
                    raise RuntimeError(error_msg)
                
                # Other errors
                error_msg = f"pdflatex failed for {description}:\n{result.stderr or result.stdout}"
                raise RuntimeError(error_msg)
            
            return result
        
        # Build exam.pdf (run twice for proper references)
        for _ in range(2):
            run_pdflatex(exam_tex, description="exam.pdf")
        
        # Build exam-solution.pdf using jobname "solution" (this triggers solution mode in tumexam.cls)
        # The Makefile uses jobname "solution" which the LaTeX class checks
        for _ in range(2):
            run_pdflatex(exam_tex, jobname='exam-solution', description="exam-solution.pdf")
    
    os.chdir(original_dir)
    
    # Find the generated PDF
    pdf_path = os.path.join(base_dir, 'exam.pdf')
    solution_pdf_path = os.path.join(base_dir, 'exam-solution.pdf')
    if not os.path.exists(pdf_path):
        raise FileNotFoundError(f"PDF not found at {pdf_path}")
    if not os.path.exists(solution_pdf_path):
        raise FileNotFoundError(f"Solution PDF not found at {solution_pdf_path}")
        
    return pdf_path, solution_pdf_path
    
    # ============================================================================
    # END OF COMMENTED LaTeX COMPILATION CODE
    # ============================================================================
    
    # Return None for PDF paths since compilation is disabled
    # The LaTeX files are still generated and available in base_dir
    # return None, None