


from QuestionModification import rewrite_exam_question
from build_new_mp_questions import modify_mp_questions
from data_model import Exam, MultipleChoiceExamQuestion, SubQuestion
from ensemble_solver import EnsembleCoordinator
from render_mc_problem import render_mc_problem, strip_non_ascii
from render_problem import render_problem
from jinja2 import Environment, FileSystemLoader
import os
import sys
import tempfile
import shutil
import subprocess
from datetime import datetime


def render_exam_tex(problem_filenames: list, template_path: str = "templates/exam_template.jinja2") -> str:
    """
    Render the exam.tex file using the Jinja template.
    
    Args:
        problem_filenames: List of problem filenames to include
        template_path: Path to the Jinja template file
        
    Returns:
        Rendered LaTeX string
    """
    template_dir = os.path.dirname(os.path.abspath(template_path))
    template_name = os.path.basename(template_path)
    
    env = Environment(loader=FileSystemLoader(template_dir))
    template = env.get_template(template_name)
    
    context = {
        'problem_files': problem_filenames,
    }
    
    return template.render(context)


def escape_latex_special_chars(text: str) -> str:
    """Escape special LaTeX characters in text."""
    # Escape special characters that have meaning in LaTeX
    replacements = {
        '&': r'\&',
        '%': r'\%',
        '$': r'\$',
        '#': r'\#',
        '_': r'\_',
        '{': r'\{',
        '}': r'\}',
        '~': r'\textasciitilde{}',
        '^': r'\textasciicircum{}',
        '\\': r'\textbackslash{}',
    }
    for old, new in replacements.items():
        text = text.replace(old, new)
    return text


def override_examconf(exam: Exam, exam_config_path: str):
    """Override the examconf.tex file with metadata from the Exam model."""
    # Parse start and end times to extract date and time components
    # Assuming start_time and end_time are in format like "YYYY-MM-DD HH:MM" or similar
    try:
        start_dt = datetime.fromisoformat(exam.start_time.replace(' ', 'T'))
        end_dt = datetime.fromisoformat(exam.end_time.replace(' ', 'T'))
    except:
        # Fallback to current date if parsing fails
        start_dt = datetime.now()
        end_dt = datetime.now()
    
    # Escape special characters in text fields
    exam_title = strip_non_ascii(exam.exam_title).replace("&", "and")
    exam_chair = strip_non_ascii(exam.exam_chair).replace("&", "and")
    examiner = strip_non_ascii(exam.examiner).replace("&", "and")
    module = strip_non_ascii(exam.module).replace("&", "and")
    
    # Generate examconf.tex content
    examconf_content = f"""% This file is generated by TUMexam.

\\title{{MOCK EXAM: {exam_title}}}
\\type{{}}
\\module{{{module}}}
\\startdate{{{start_dt.day}}}{{{start_dt.month}}}{{{start_dt.year}}}
\\stopdate{{{end_dt.day}}}{{{end_dt.month}}}{{{end_dt.year}}}
\\starttime{{{start_dt.strftime('%H:%M')}}}
\\stoptime{{{end_dt.strftime('%H:%M')}}}
\\lang{{english}}
\\department{{School of Computation, Information, and Technology}}
\\chair{{{exam_chair}}}
\\examiner{{EXAMINATOR}}

\\submissionfalse
\\singlepasstrue
\\halfcreditstrue
\\registrationstickertrue
\\externalproblemsfalse
\\coversheetfalse
\\booklet
\\seriffalse
\\subproblemarabicfalse
\\minimaltitlepagefalse

\\noproblemcreditsfalse
\\noproblemfalse
\\notitlefalse
\\nocorrectorboxfalse
\\singlesidefalse
"""
    
    # Write the examconf.tex file
    with open(exam_config_path, 'w') as f:
        f.write(examconf_content)


def build_exam(exam: Exam, status_callback=None) -> tuple[str, str]:
    """
    Build exam LaTeX files.
    
    Args:
        exam: Exam object to build
        status_callback: Optional callback function(status_message, progress) for UI updates
    """
    if status_callback:
        status_callback("Setting up workspace...", 0.1)
    
    tmp_dir = tempfile.mkdtemp()
    shutil.copytree('./latex_template', os.path.join(tmp_dir, 'latex_template'))
    base_dir = os.path.join(tmp_dir, 'latex_template')
    exam_config = f"{base_dir}/conf/generated/examconf.tex"
    
    if status_callback:
        status_callback("Configuring exam metadata...", 0.2)
    
    override_examconf(exam, exam_config)

    if status_callback:
        status_callback("Creating problem files...", 0.3)

    # Create problem files
    problems_dir = os.path.join(base_dir, 'problems')
    os.makedirs(problems_dir, exist_ok=True)

    problem_filenames = []
    total_problems = len(exam.exam_content.problems)
    solver = EnsembleCoordinator()

    for idx, problem in enumerate(exam.exam_content.problems, start=1):
        if status_callback:
            progress = 0.3 + (idx / total_problems) * 0.4
            status_callback(f"Rendering problem {idx} of {total_problems}...", progress)
        
        problem_filename = f"problem_{idx:02d}.tex"
        problem_path = os.path.join(problems_dir, problem_filename)
        
        # Render the problem using the Jinja template
        if isinstance(problem, MultipleChoiceExamQuestion):
            new_problem = modify_mp_questions(problem)
            problem_latex = render_mc_problem(new_problem, problem_number=idx)
        else:
            print(type(problem))
            new_problem = rewrite_exam_question(problem)
            q_description = new_problem.question_description_latex if new_problem.question_description_latex else ""
            for sub_question in new_problem.sub_questions:
                if isinstance(sub_question, SubQuestion):
                    print("Solving sub-question")
                    solution = solver.solve(q_description + "\n" + sub_question.question_text_latex)
                    sub_question.question_answer_latex = solution['final_answer']
            problem_latex = render_problem(new_problem, problem_number=idx)
        
        if not problem_latex is None:
            with open(problem_path, 'w') as f:
                f.write(problem_latex)
                problem_filenames.append(problem_filename)

    if status_callback:
        status_callback("Generating main exam template...", 0.8)

    # Generate exam.tex from template
    exam_tex_content = render_exam_tex(problem_filenames)
    exam_tex_path = os.path.join(base_dir, 'exam.tex')
    with open(exam_tex_path, 'w') as f:
        f.write(exam_tex_content)
    
    if status_callback:
        status_callback("Starting Rendering of exam.tex...", 0.9)
      
    # ============================================================================
    # LaTeX PDF COMPILATION - COMMENTED OUT FOR WINDOWS COMPATIBILITY
    # ============================================================================
    # The following code compiles LaTeX to PDF. This requires LaTeX installation
    # (MiKTeX or TeX Live) which is not available on all Windows systems.
    # Uncomment this section if you have LaTeX installed and want to generate PDFs.
    # ============================================================================
    
    # Build the exam PDF - cross-platform solution
    # Priority: Use Makefile if available (macOS/Linux), fallback to pdflatex (Windows)
    original_dir = os.getcwd()
    os.chdir(base_dir)
    
    # Check if make is available (Unix/Linux/Mac - typically available by default)
    make_available = shutil.which('make') is not None
    

    # Use Makefile if available (preferred method for macOS/Linux)
    # This preserves the original behavior for Unix-based systems
    result = os.system('make')
    result_2 = os.system('make solution')
    if result != 0:
        raise RuntimeError(f"make failed with exit code {result}")
    if result_2 != 0:
        raise RuntimeError(f"make solution failed with exit code {result_2}")
    if status_callback:
        status_callback("Finished Creating Exam", 1.0)

    os.chdir(original_dir)
    
    # Find the generated PDF
    pdf_path = os.path.join(base_dir, 'exam.pdf')
    solution_pdf_path = os.path.join(base_dir, 'exam-solution.pdf')
    if not os.path.exists(pdf_path):
        raise FileNotFoundError(f"PDF not found at {pdf_path}")
    if not os.path.exists(solution_pdf_path):
        raise FileNotFoundError(f"Solution PDF not found at {solution_pdf_path}")
        
    return pdf_path, solution_pdf_path
    
    # ============================================================================
    # END OF COMMENTED LaTeX COMPILATION CODE
    # ============================================================================
    
    # Return None for PDF paths since compilation is disabled
    # The LaTeX files are still generated and available in base_dir
    # return None, None