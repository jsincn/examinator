


from QuestionModification import rewrite_exam_question
from build_new_mp_questions import modify_mp_questions
from data_model import Exam, MultipleChoiceExamQuestion
from render_mc_problem import render_mc_problem, strip_non_ascii
from render_problem import render_problem
from jinja2 import Environment, FileSystemLoader
import os
import tempfile
import shutil
from datetime import datetime


def render_exam_tex(problem_filenames: list, template_path: str = "templates/exam_template.jinja2") -> str:
    """
    Render the exam.tex file using the Jinja template.
    
    Args:
        problem_filenames: List of problem filenames to include
        template_path: Path to the Jinja template file
        
    Returns:
        Rendered LaTeX string
    """
    template_dir = os.path.dirname(os.path.abspath(template_path))
    template_name = os.path.basename(template_path)
    
    env = Environment(loader=FileSystemLoader(template_dir))
    template = env.get_template(template_name)
    
    context = {
        'problem_files': problem_filenames,
    }
    
    return template.render(context)


def escape_latex_special_chars(text: str) -> str:
    """Escape special LaTeX characters in text."""
    # Escape special characters that have meaning in LaTeX
    replacements = {
        '&': r'\&',
        '%': r'\%',
        '$': r'\$',
        '#': r'\#',
        '_': r'\_',
        '{': r'\{',
        '}': r'\}',
        '~': r'\textasciitilde{}',
        '^': r'\textasciicircum{}',
        '\\': r'\textbackslash{}',
    }
    for old, new in replacements.items():
        text = text.replace(old, new)
    return text


def override_examconf(exam: Exam, exam_config_path: str):
    """Override the examconf.tex file with metadata from the Exam model."""
    # Parse start and end times to extract date and time components
    # Assuming start_time and end_time are in format like "YYYY-MM-DD HH:MM" or similar
    try:
        start_dt = datetime.fromisoformat(exam.start_time.replace(' ', 'T'))
        end_dt = datetime.fromisoformat(exam.end_time.replace(' ', 'T'))
    except:
        # Fallback to current date if parsing fails
        start_dt = datetime.now()
        end_dt = datetime.now()
    
    # Escape special characters in text fields
    exam_title = strip_non_ascii(exam.exam_title).replace("&", "and")
    exam_chair = strip_non_ascii(exam.exam_chair).replace("&", "and")
    examiner = strip_non_ascii(exam.examiner).replace("&", "and")
    module = strip_non_ascii(exam.module).replace("&", "and")
    
    # Generate examconf.tex content
    examconf_content = f"""% This file is generated by TUMexam.

\\title{{{exam_title}}}
\\type{{}}
\\module{{{module}}}
\\startdate{{{start_dt.day}}}{{{start_dt.month}}}{{{start_dt.year}}}
\\stopdate{{{end_dt.day}}}{{{end_dt.month}}}{{{end_dt.year}}}
\\starttime{{{start_dt.strftime('%H:%M')}}}
\\stoptime{{{end_dt.strftime('%H:%M')}}}
\\lang{{english}}
\\department{{School of Computation, Information, and Technology}}
\\chair{{{exam_chair}}}
\\examiner{{{examiner}}}

\\submissionfalse
\\singlepasstrue
\\halfcreditstrue
\\registrationstickertrue
\\externalproblemsfalse
\\coversheetfalse
\\booklet
\\seriffalse
\\subproblemarabicfalse
\\minimaltitlepagefalse

\\noproblemcreditsfalse
\\noproblemfalse
\\notitlefalse
\\nocorrectorboxfalse
\\singlesidefalse
"""
    
    # Write the examconf.tex file
    with open(exam_config_path, 'w') as f:
        f.write(examconf_content)


def build_exam(exam: Exam, status_callback=None) -> tuple[str, str]:
    tmp_dir = tempfile.mkdtemp()
    shutil.copytree('./latex_template', os.path.join(tmp_dir, 'latex_template'))
    base_dir = os.path.join(tmp_dir, 'latex_template')
    exam_config = f"{base_dir}/conf/generated/examconf.tex"
    
    override_examconf(exam, exam_config)

    # Create problem files
    problems_dir = os.path.join(base_dir, 'problems')
    os.makedirs(problems_dir, exist_ok=True)

    problem_filenames = []
    for idx, problem in enumerate(exam.exam_content.problems, start=1):
        problem_filename = f"problem_{idx:02d}.tex"
        problem_path = os.path.join(problems_dir, problem_filename)
        
        # Render the problem using the Jinja template
        if isinstance(problem, MultipleChoiceExamQuestion):
            new_problem = modify_mp_questions(problem)
            problem_latex = render_mc_problem(new_problem, problem_number=idx)
        else:
            new_problem = rewrite_exam_question(problem)
            problem_latex = render_problem(new_problem, problem_number=idx)

        if not problem_latex is None:
            with open(problem_path, 'w') as f:
                f.write(problem_latex)
                problem_filenames.append(problem_filename)

        # else:
            # new_problem = rewrite_exam_question(problem)
            # problem_latex = render_problem(problem, problem_number=idx)
        
        

    # Generate exam.tex from template
    exam_tex_content = render_exam_tex(problem_filenames)
    exam_tex_path = os.path.join(base_dir, 'exam.tex')
    with open(exam_tex_path, 'w') as f:
        f.write(exam_tex_content)
      
    # Build the exam PDF using the Makefile
    original_dir = os.getcwd()
    os.chdir(base_dir)
    result = os.system('make')
    result_2 = os.system('make solution')
    os.chdir(original_dir)
    if result != 0:
        raise RuntimeError(f"make failed with exit code {result}")
    if result_2 != 0:
        raise RuntimeError(f"make solution failed with exit code {result_2}")

    # Find the generated PDF
    pdf_path = os.path.join(base_dir, 'exam.pdf')
    solution_pdf_path = os.path.join(base_dir, 'exam-solution.pdf')
    if not os.path.exists(pdf_path):
        raise FileNotFoundError(f"PDF not found at {pdf_path}")
    if not os.path.exists(solution_pdf_path):
        raise FileNotFoundError(f"Solution PDF not found at {solution_pdf_path}")
        
    return pdf_path, solution_pdf_path